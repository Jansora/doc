---
title: 2. 创建和销毁对象
toc: "menu"
---
<embed src="../../Author.md" />

## 2.1 用静态工厂方法代替构造器
1. 构造函数方法名称与类名相同, 在多个构造函数重载的时候比较费解, 静态方法可以通过不同的方法名规避掉不同的重载来避免歧义, 便于理解
2. 不必每次调用都创建新的对象, 尤其是在一些不变的对象上, 较少开销
3. 静态工厂方法可以自主决定返回的类型(尤其指在面向接口编程时), 而构造器不可以
<Alert type="warning">在实例化对象设计时, 优先考虑静态工厂, 其次才是构造函数</Alert>
   
## 2.2 遇到多个构造器参数时要考虑使用构建器
静态工厂方法和构造器都无法处理参数过多的问题, 这个时候一般有三种解决方法.
1. 添加多个构造器 (参数过多时较难理解) 
2. 采用 JavaBean 方式 (通过 getter / setter 方式可能会导致线程不安全的情况)
3. 通过 Builder 辅助类的方式来实例化对象 (会有少许的性能消耗, 参数过多时推荐此方式)

## 2.3 用私有构造器或枚举类型强化 Singleton 属性
2.3.1 用私有构造器来强化 Singleton 属性
1. 私有构造器 + public final 常量来保证只能被实例化一次
2. 私有构造器 + private final 常量 + 静态工厂方法来保证只能被实例化一次

2.3.2 声明一个单元素的枚举类, 使用该枚举类来包裹 Singleton 元素

## 2.4 通过私有构造器强化不可实例化的能力
当 class 没有包含构造函数时, 系统会自动提供一个 public no-args 的 default 构造器来使得该类可以被实例化, 但是有些工具类只提供了静态工厂方法, **不希望被实例化时** , 我们可以显式的提供一个私有构造器, 那么该 class 就不可被实例化

## 2.5 优先考虑依赖注入来引用资源
<Alert type="info">
什么是依赖注入?
当创建类的实例时(通过构造器), 就把依赖的资源传到构造器中, 这就是依赖注入
</Alert>    
虽然依赖注入极大地提升了灵活性和可测试性, 但是他也会导致大型项目混乱不堪, 一般通过依赖注入框架来解决此类问题, 比如 `Spring`
<Alert type="warning">
注:
当使用 Singleton 类实例时, 不要依赖底层资源类, 因为这可能会导致 Singleton 实例状态发生变化!
</Alert>    

## 2.6 避免创建不必要的对象
避免创建不必要的对象可以提高性能. 有以下几点可以规避掉
1. 尽量使用静态工程方法来创建对象, 避免创建不必要的对象
2. 尽可能的复用对象, 尤其是在循环体等内部.
3. 自动装箱是有代价的, 尽量使用基本类型而不是装箱类型, 来避免无意识的自动装箱
4. 并不是所有对象的创建代价都很昂贵, 小对象的创建和回收很廉价.
5. 维护对象池并不是一个好的做法, 除非对象池的对象代价比较大, 比如线程池, 数据库连接池.




